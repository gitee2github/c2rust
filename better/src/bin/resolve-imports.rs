#![feature(rustc_private)]
#![feature(box_patterns)]
#![feature(str_split_once)]

extern crate env_logger;

use crate::def_id::{DefId, LOCAL_CRATE};

use itertools::Itertools;
use better::{
    analysis,
    colored::*,
    compiler_interface::*,
    constants::*,
    io::{FileIO, OutputMode},
    lazy_static::lazy_static,
    ptr_provenance::*,
    rustc_driver,
    
    rustc_hir::{intravisit::FnKind, *},
    rustc_lint::{LateContext, LateLintPass, LintContext, LintPass},
    rustc_span::{sym, FileName, Span, FileNameDisplayPreference},
    rustc_target::spec::abi::Abi,
    Atom,
};
use rustfix::{Replacement, Snippet, Solution, Suggestion};
use std::{
    collections::{BTreeSet, HashMap, HashSet},
    panic,
    path::PathBuf,
    sync::{Arc, Mutex},
};

lazy_static! {
    /// Rustfix suggestions for editing the source files
    static ref RUSTFIX_SUGGESTIONS: Mutex<HashMap<PathBuf, Vec<Suggestion>>> = Mutex::new(HashMap::default());
}

/// Returns the name of the definition at given HIR node in current crate
fn get_hir_qname(ctx: &LateContext<'_>, hir_id: HirId) -> FnName {
    let def_id = DefId {
        krate: LOCAL_CRATE,
        index: ctx.tcx.hir().local_def_id(hir_id).local_def_index,
    };
    ctx.get_def_path(def_id)
        .iter()
        .map(|segment| segment.to_string())
        .filter(|s| !s.is_empty())
        .join("::")
}

/// Checks if the given function is generated by the compiler
/// TODO
fn is_synthetic_fn(_fn_decl: &FnDecl<'_>, body: &Body<'_>) -> bool {
    body.value.span.in_derive_expansion()
}

/// Get the field names of a struct or union (or field indices as
/// strings if it is a tuple struct)
fn get_fields(variant_data: &VariantData) -> Vec<String> {
    variant_data
        .fields()
        .iter()
        .map(|f| f.ident.as_str().to_string())
        .collect()
}

// Use interned strings for names, we use `Name` instead of `Symbol`
// to prevent clashes with [`Symbol`] used and defined by rustc.
type Name = Atom;

/// Information about which parts of the source code are relevant to
/// an external type
#[derive(Default, Eq, PartialEq)]
struct ItemInfo {
    /// Unqualified name
    unqual_name: String,
    /// The span for this definition
    span: Span,
    /*
    /// The spans for commenting out (e.g. `#[derive(..)]` spans) when
    /// removing this item
    to_comment_out: Vec<Span>,
    /// The spans to remove when removing this item, e.g. the annotations
    to_remove: Vec<Span>,
    */
    /// End of the parent `extern { .. }` statement, so that we can add this item if need be
    end_of_extern: Span,
    /// The parent module, so that we can look up imported names
    parent_mod: String,
}

/// A type signature to match up ADTs with the same shape and unqualified names
#[derive(Debug, PartialEq, Eq, Hash)]
enum TypeSig {
    /// An unknown type (coming from type definitions)
    Unknown,
    /// A struct with field names.
    ///
    /// TODO: field sizes/shapes as well for better matching. That
    /// would require some constraint solving
    Struct(Vec<String>),
    /// A C union with field names
    Union(Vec<String>),
}

/// A pass for the rewriting part of this tool
struct RewritePass {
    /// Call graph built by pointer provenance
    call_graph: CallGraph,
    /// A mapping of structs and unions to their unique definitions in the crate
    type_defs: HashMap<String, HashMap<TypeSig, String>>,
    /// Information about unresolved names, we post-process them to
    /// resolve them
    ///
    /// QualifiedName -> (UnqualifiedName, Spans)
    unresolved_types: HashMap<String, ItemInfo>,
    
    /// Whether to remove `#[repr(..)]`
    remove_repr: bool,
    /// Whether to remove `#[derive(..)]`
    remove_derive: bool,

    /// Whether to remove `#[no_mangle]`
    remove_no_mangle: bool,
    /// Keep track of a unique ID for removed extern functions so we can remove their `no_mangle` attribute
    removed_fns: HashSet<Span>,
    /// Names imported in each module
    imported_names: HashMap<String, HashSet<String>>,
    /// Name of the current module being processed
    current_mod: String,
}

impl RewritePass {
    pub fn new() -> Box<LatePass> {
        // println!("131: A new RewritePass!");
        Box::new(RewritePass {
            call_graph: analysis::result::<CallGraph>().unwrap(),
            type_defs: HashMap::default(),
            remove_repr: false,
            remove_derive: false,
            remove_no_mangle: false,
            removed_fns: HashSet::default(),
            imported_names: HashMap::default(),
            // to_owned(): &str -> String, 把数据从栈中复制到堆中，成为自己的数据
            current_mod: "".to_owned(),
            unresolved_types: HashMap::default(),
        })
    }

    fn calls_c_fns_we_handle(&self, ctx: &LateContext, fn_name: &Name) -> bool {
        if let Some(callees) = &self.call_graph.closure().unwrap().get(fn_name) {
            C_FNS_WE_HANDLE.iter().any(|name| {
                callees.contains(&Name::from(format!("{}::{}", local_crate_name(ctx), name)))
            })
        } else {
            false
        }
    }
    
    // Return a boolean indicating whether the given function is safe
    // A function is considered safe if it does not have any unsafe behavior and does not call any C functions that the linter can handle.
    fn is_safe_fn(&self, ctx: &LateContext, fn_name: &Name) -> bool {
        self.call_graph
            .unsafe_behavior()
            .get(fn_name)
            .map_or(true, |s| s.is_empty())
            && !self.calls_c_fns_we_handle(ctx, fn_name)
    }

    /// Generates the string representation of a version of the given
    /// fn header that is not unsafe.
    fn safe_header_snippet(fn_header: FnHeader) -> String {
        assert_eq!(fn_header.asyncness, IsAsync::NotAsync);
        let const_str = if fn_header.is_const() { "const " } else { "" };
        let extern_str = if fn_header.abi == Abi::Rust {
            "".to_string()
        } else {
            format!("extern \"{}\" ", fn_header.abi.name())
        };
        format!(" {}{}fn ", const_str, extern_str)
    }

    fn process_fn(
        &mut self,
        ctx: &LateContext<'_>,
        name: Name,
        fn_header: FnHeader,
        header_span: Span,
    ) {
        let can_remove_unsafe = self.is_safe_fn(ctx, &name);
        // check if we can remove `unsafe`
        if fn_header.unsafety == Unsafety::Unsafe && can_remove_unsafe {
            self.make_suggestion(
                ctx,
                header_span,
                format!("remove `unsafe` from {}", name),
                Self::safe_header_snippet(fn_header),
            );
        }
    }
    
    // Create a suggestion for a possible fix to a coding issue found by the program.
    fn make_suggestion(
        &self,
        ctx: &LateContext<'_>,
        span: Span,
        message: String,
        replacement: String,
    ) {
        use rustfix::{LinePosition, LineRange};
        // map source code spans to their corresponding file names
        let source_map = ctx.sess().source_map();
        let fname = source_map.span_to_filename(span);
        // If the file name is not a real file, the function prints a warning and returns.
        let fname_real = match fname {
            FileName::Real(ref n) => n,
            _ => {
                println!(
                    "{}",
                    format!("WARNING: Attempted to fix generated code at {:?}", span)
                        .bold()
                        .red()
                );
                return;
            },
        };
        // Get the source file associated with the file name
        // 通过文件名，获得对应文件资源的读写指针？
        let file = source_map.get_source_file(&fname).unwrap();
        // Look up the file position corresponding to the start and end of the given Span using the lookup_file_pos_with_col_display method
        // lookup_file_pos_with_col_display() - 返回值:
        // a tuple containing the line number, column number, and byte offset of the position.
        // This information is used to create a LineRange object.
        let lo = file.lookup_file_pos_with_col_display(span.lo());
        let hi = file.lookup_file_pos_with_col_display(span.hi());
        // 用上面lookup_file_pos_with_col_display()的返回值，创建了一个 LineRange object.
        let line_range = LineRange {
            start: LinePosition {
                line: lo.0,
                column: lo.2,
            },
            end: LinePosition {
                line: hi.0,
                column: hi.2,
            },
        };
        let file_name_display_preference = FileNameDisplayPreference::Remapped;
        // The Snippet object represents a piece of source code within a file.
        let snippet = Snippet {
            // file_name: file_name.as_string();
            file_name: (*fname_real).to_string_lossy(file_name_display_preference).to_string(),
            line_range,
            range: (file.bytepos_to_file_charpos(span.lo()).0)
                ..(file.bytepos_to_file_charpos(span.hi()).0),
            // text range (using byte offsets) corresponding to the given Span
            // The text field of the Snippet object is initialized with a tuple containing three empty Strings 
            // and the source code text corresponding to the given Span.
            text: (
                "".into(),
                source_map.span_to_snippet(span).unwrap(),
                "".into(),
            ),
        };
        // After creating the Snippet object, 
        // the function acquires a lock on a global singleton RUSTFIX_SUGGESTIONS
        // and uses the file name to get a reference to a vector of suggestions associated with that file. 
        // If no such vector exists yet, a new empty vector is created and added to the map of suggestions.
        let mut suggestions = RUSTFIX_SUGGESTIONS.lock().unwrap();

        suggestions
             //   .entry(fname_real.local_path().into())
            .entry(fname_real.local_path().unwrap().into())
            .or_insert(vec![])
            .push(Suggestion {
                message: "".to_owned(),
                snippets: vec![snippet.clone()],
                solutions: vec![Solution {
                    message,
                    replacements: vec![Replacement {
                        snippet,
                        replacement,
                    }],
                }],
            });
    }

    fn deduplicate_struct(
        &mut self,
        ctx: &LateContext,
        unqual_name: &str,
        qual_name: String,
        type_sig: TypeSig,
        struct_def_span: Span,
    ) {
        if let Some(matching_sigs) = self.type_defs.get(unqual_name) {
            // ADT名称相同
            let def_name = if let Some(def_qname) = matching_sigs.get(&type_sig) {
                // 同名ADT，定义也相同(完全相同，即重复类型定义)
                def_qname
            } else {
                // 同名ADT，定义不同
                // 创建一条新的记录，<unqual_name, <type_sig, def_name>>
                // unqual_name:  ADT的名称，size_t
                // def_name:     crate内部路径+名称；比如 src::apps::json_parse::size_t
                // top + rest:   src + apps::json_parse::size_t
                // qual_name:    crate名+路径+名称  比如 lib::src::apps::json_parse::size_t 
                // there are no matching signatures, introduce this definition as the canonical one for its signature
                self.type_defs
                    .entry(unqual_name.to_owned())
                    .or_default()
                    .insert(type_sig, qual_name.split_once("::").unwrap().1.to_owned());
                // log::warn!("There are multiple definitions with the same unqualified name to rewrite the typedef `{}` as", qual_name)
                return;
            };
            println!("def_name: {}", def_name);
            let (top, rest) = def_name.split_once("::").unwrap();
            println!("top: {}; rest: {}", top, rest);
            println!("local_crate_name: {}", local_crate_name(ctx));
            // 如果定义就在当前crate内，
            let name_to_import = if top == local_crate_name(ctx) {
                rest
            } else {
                &def_name
            };
            println!("name_to_import: {}", name_to_import);
            let snippet = if self.imported_names[self.current_mod.as_str()].contains(unqual_name) {
                // 如果ADT的定义就当前模块，不需要引入，所以snippet就是空
                "".to_string()
            } else {
                // 如果ADT的定义不在当前木块，就需要引入
                // 引入的语句: 
                self.imported_names
                    .get_mut(self.current_mod.as_str())
                    .unwrap()
                    .insert(unqual_name.to_string());
                format!("pub use crate::{};", name_to_import)
            };
            println!("snippet: {}", snippet);
            // this struct is already defined, deduplicate it
            self.make_suggestion(
                ctx,
                struct_def_span,
                "deduplicate struct".to_owned(),
                snippet,
            );
            // mark repr and automatically_derived attributes related to this struct as to be removed_fns
            self.remove_repr = true;
            self.remove_derive = true;
        } else {
            // there is no matching type name, register this as the first one
            self.type_defs
                .entry(unqual_name.to_owned())
                .or_default()
                .insert(type_sig, qual_name.split_once("::").unwrap().1.to_owned());
        }
    }
}

impl LintPass for RewritePass {
    fn name(&self) -> &'static str {
        "RewritePass"
    }
}

impl<'tcx> LateLintPass<'tcx> for RewritePass {
    fn check_mod(
        &mut self,
        ctx: &LateContext<'tcx>,
        _mod: &'tcx Mod<'tcx>,
        _: Span,
        hir_id: HirId,
    ) {
        // reset the imports
        self.current_mod = get_hir_qname(ctx, hir_id);
        println!("Crurrent_mod : {}", self.current_mod);
        self.imported_names
            .insert(self.current_mod.clone(), HashSet::default());
    }

    fn check_item(&mut self, ctx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {
        println!("fn check_item : ");
        if item.span.in_derive_expansion() {
            let attrs = ctx.tcx.hir().attrs(item.hir_id());
                for attr in attrs{
                    self.check_attribute(ctx, attr);
                }
            return;
        }
        /*  Define a closure that takes no arguments and 
         returns the fully qualified name of the definition associated with item.hir_id() in the current crate. */ 
        let name = || get_hir_qname(ctx, item.hir_id());
        let crate_name = local_crate_name(ctx);
        println!(" Crate_Name: {} ", crate_name);
        // end of this foreign module ?
        let end_of_extern = item.span.shrink_to_hi();
        // don't remove attributes related to structs by default
        self.remove_repr = false;
        self.remove_derive = false;
        self.remove_no_mangle = false;
        match &item.kind {
            // Handle foreign module (`extern { ... }`) declarations
            ItemKind::ForeignMod {
                items: foreign_items,
                ..
            } => {
                // use BTreeSet to keep the functions in a stable order for rewrite
                let mut items_to_import: BTreeSet<String> = BTreeSet::new();
                for foreign_item in *foreign_items {
                    let unqual_name = &*foreign_item.ident.as_str();
                    if matches!(ctx.tcx.hir().foreign_item((*foreign_item).id).kind, ForeignItemKind::Fn(..)) {
                        if let Some(def_qname) = self
                            .call_graph
                            .defined_fns
                            .get(&Name::from(&*foreign_item.ident.as_str()))
                        {
                            // this function is defined in another
                            // module, remove the extern definition
                            // and add it to the fns to import via
                            // `use`
                            self.make_suggestion(
                                ctx,
                                foreign_item.span,
                                "remove extern function that is defined in another module"
                                    .to_owned(),
                                "".to_owned(),
                            );
                            let current_names =
                                self.imported_names.get_mut(&self.current_mod).unwrap();
                            if !current_names.contains(unqual_name) {
                                current_names.insert(unqual_name.to_string());
                                items_to_import.insert(def_qname.to_string());
                            }
                            self.removed_fns.insert(foreign_item.span);
                        }
                    } else if matches!(ctx.tcx.hir().foreign_item((*foreign_item).id).kind, ForeignItemKind::Type) {
                        if let Some(matching_sigs) = self.type_defs.get(unqual_name) {
                            self.make_suggestion(
                                ctx,
                                foreign_item.span,
                                "remove extern type that is also declared in another module"
                                    .to_owned(),
                                "".to_owned(),
                            );
                            let current_names =
                                self.imported_names.get_mut(&self.current_mod).unwrap();
                            if !current_names.contains(unqual_name) {
                                assert!(
                                    matching_sigs.len() == 1,
                                    "multiple matching definitions for the same extern at {:?}: {:?}",
                                    foreign_item.span,
                                    matching_sigs
                                );
                                let def_qname = matching_sigs.values().last().unwrap();
                                current_names.insert(unqual_name.to_string());
                                items_to_import.insert(def_qname.to_string());
                            }
                        } else {
                            // TODO: do not add this to the
                            // definitions, instead add this to the
                            // unresolved information

                            // name() gives the name of the enclosing
                            // module for foreign type declarations due to
                            // rustc's understanding of definitions. so,
                            // we have to do the following trick
                            let name = format!("{}::{}", name(), unqual_name);
                            /*
                            self.type_defs
                                .insert(unqual_name.to_string(), name);
                            */
                            self.unresolved_types.insert(
                                name,
                                ItemInfo {
                                    unqual_name: unqual_name.to_owned(),
                                    span: foreign_item.span,
                                    end_of_extern,
                                    parent_mod: self.current_mod.clone(),
                                },
                            );
                        }
                    }
                }
                if !items_to_import.is_empty() {
                    let use_stmts = items_to_import
                        .into_iter()
                        .map(|name| {
                            // import the name in a crate name-agnostic way
                            let (top, rest) = name.split_once("::").unwrap();
                            let name_to_import = if top == crate_name { rest } else { &name };
                            format!("\npub use crate::{};", name_to_import)
                        })
                        .join("");
                    self.make_suggestion(
                        ctx,
                        end_of_extern,
                        "import extern functions that are defined in other modules".to_owned(),
                        use_stmts,
                    );
                }
            },
            // handle and deduplicate struct definitions
            ItemKind::Struct(variant_data, _) => {
                let unqual_name = item.ident.as_str();
                println!("ItemKind::Struct : {}", unqual_name);
                self.deduplicate_struct(
                    ctx,
                    &unqual_name,
                    name(),
                    TypeSig::Struct(get_fields(variant_data)),
                    item.span,
                );
                let attrs = ctx.tcx.hir().attrs(item.hir_id());
                for attr in attrs{
                    self.check_attribute(ctx, attr);
                } // , data.fields(), generics);
                                  
            },
            ItemKind::Union(variant_data, _) => {
                let unqual_name = item.ident.as_str();
                self.deduplicate_struct(
                    ctx,
                    &unqual_name,
                    name(),
                    TypeSig::Union(get_fields(variant_data)),
                    item.span,
                );
                let attrs = ctx.tcx.hir().attrs(item.hir_id());
                for attr in attrs{
                    self.check_attribute(ctx, attr);
                } // , data.fields(), generics);
                  
            },
            ItemKind::TyAlias(..) => {
                let unqual_name = item.ident.as_str();
                if !unqual_name.starts_with("C2RustUnnamed") {
                    self.deduplicate_struct(ctx, &unqual_name, name(), TypeSig::Unknown, item.span);
                    let attrs = ctx.tcx.hir().attrs(item.hir_id());
                    for attr in attrs{
                        self.check_attribute(ctx, attr);
                    }
                }
                
            },
            // ItemKind::Impl(..) => {
            //     let attrs = ctx.tcx.hir().attrs(item.hir_id());
            //     for attr in attrs{
            //         self.check_attribute(ctx, attr);
            //     }
            // }
            _ => {},
        }
    }

    fn check_crate_post(&mut self, ctx: &LateContext<'tcx>) {
        println!("fn check_crate_post");
        let crate_name = local_crate_name(ctx);
        // resolve unresolved items if possible
        let mut items_to_import_per_mod: HashMap<Span, BTreeSet<String>> = HashMap::new();
        for (qual_name, info) in &self.unresolved_types {
            if let Some(type_def) = self.type_defs.get(&info.unqual_name) {
                assert_eq!(
                    type_def.len(),
                    1,
                    "There are multiple type definitions with the name {}",
                    info.unqual_name
                );
                let (sig, def_qname) = type_def.iter().last().unwrap();
                assert_ne!(qual_name, def_qname, "Circular type definition!");

                if *sig == TypeSig::Unknown {
                    log::warn!(
                        "resolving extern type `{}` to typedef `{}`. this may cause circular type definitions!",
                        qual_name,
                        def_qname
                    );
                }

                self.make_suggestion(
                    ctx,
                    info.span,
                    "remove extern type that is also declared in another module".to_owned(),
                    "".to_owned(),
                );
                let current_names = self.imported_names.get_mut(&info.parent_mod).unwrap();
                if !current_names.contains(&info.unqual_name) {
                    current_names.insert(info.unqual_name.clone());
                    items_to_import_per_mod
                        .entry(info.end_of_extern)
                        .or_default()
                        .insert(def_qname.clone());
                }
            }
        }

        for (end_of_extern, items_to_import) in items_to_import_per_mod {
            let use_stmts = items_to_import
                .into_iter()
                .map(|name| {
                    // import the name in a crate name-agnostic way
                    let (top, rest) = name.split_once("::").unwrap();
                    let name_to_import = if top == crate_name { rest } else { &name };
                    format!("\npub use crate::{};", name_to_import)
                })
                .join("");
            self.make_suggestion(
                ctx,
                end_of_extern,
                "import extern functions that are defined in other modules".to_owned(),
                use_stmts,
            );
        }
    }

    fn check_item_post(&mut self, _: &LateContext<'tcx>, _: &'tcx Item<'tcx>) {
        println!("fn check_item_post");
        // stop removing #[no_mangle] after the extern block
        self.remove_no_mangle = false;
    }

    fn check_foreign_item(&mut self, _: &LateContext<'tcx>, item: &'tcx ForeignItem<'tcx>) {
        println!("fn check_foreign_item");
        self.remove_no_mangle = self.removed_fns.contains(&item.span);
    }

    // fn check_fn_post(
    // TODO
    // }

    fn check_attribute(
        &mut self,
        ctx: &LateContext<'tcx>,
        attr: &'tcx better::rustc_ast::ast::Attribute,
    ) {
        println!("fn check_attribute");
        // remove the attributes related to the structs that are removed
        if !attr.is_doc_comment() {
            // println!("!attr.is_doc_comment()");
            // println!("self.remove_repr: {} ; self.remove_derive: {} ;", self.remove_repr, self.remove_derive);
            // println!("attr.has_name(sym::repr): {} ; attr.has_name(sym::automatically_derived): {} ;", attr.has_name(sym::repr), attr.has_name(sym::automatically_derived));
            if self.remove_repr && attr.has_name(sym::repr) {
                // println!("remove_repr");
                self.make_suggestion(ctx, attr.span, "delete repr".to_owned(), "".to_owned());
                self.remove_repr = false;
            } else if self.remove_derive && attr.has_name(sym::automatically_derived) {
                // println!("remove_derive");
                let begin_span = ctx
                    .sess()
                    .source_map()
                    .span_extend_to_prev_char(attr.span, '\n', true)
                    .shrink_to_lo();
                self.make_suggestion(
                    ctx,
                    begin_span,
                    "comment out derive".to_owned(),
                    "// ".to_owned(),
                );
                self.remove_derive = false;
            } else if self.remove_no_mangle && attr.has_name(sym::no_mangle) {
                self.make_suggestion(ctx, attr.span, "delete no_mangle".to_owned(), "".to_owned());
                self.remove_no_mangle = false;
            }
        }
    }
}

pub fn main() {

    rustc_driver::init_rustc_env_logger();

    run_compiler(&vec![], vec![PtrProvenancePass::new]);
    run_compiler(&vec![], vec![RewritePass::new]);


    println!("{}", "Unsafe removal suggestions:".bold().green());

    for (file, suggestions) in RUSTFIX_SUGGESTIONS.lock().unwrap().iter() {
        println!("For file {}:", file.to_str().unwrap());

        for suggestion in suggestions.iter() {
            let solution = &suggestion.solutions[0];
            println!("solution.message: {}", solution.message);
            for replacement in &solution.replacements {
                println!(" - replace {:?}", replacement.snippet.text);
                println!("   with   `{}`", replacement.replacement);
                println!(
                    "   at {} {}:{}-{}:{}",
                    replacement.snippet.file_name,
                    replacement.snippet.line_range.start.line,
                    replacement.snippet.line_range.start.column,
                    replacement.snippet.line_range.end.line,
                    replacement.snippet.line_range.end.column,
                );
            }
        }
    }
    let cfg = better::Config {
        output_path: None,
        output_mode: OutputMode::Overwrite,
    };

    let file_io = FileIO::new(&cfg);
    // 开始改写：控制台输出：Applying fixes
    println!("{}", "Applying fixes".bold().green());

    for (file, suggestions) in RUSTFIX_SUGGESTIONS.lock().unwrap().drain() {
        println!("Rewriting file {}:", file.to_str().unwrap());

        let fixed_source_code =
            rustfix::apply_suggestions(&file_io.read_file(&file).unwrap(), &suggestions).unwrap();
        file_io.write_file(&file, &fixed_source_code).unwrap();
    }
    // 检测功能是否完全实现
    let orig_args: Vec<String> = std::env::args().collect();
    let args = better::cli::read_env(orig_args);
    let exit_code = run_compiler_with_setup(args, &vec![], vec![], |_| {}).0;
    if exit_code == 0 {
        println!(
            "DONE: {}",
            "The compiler successfully compiles the code".green()
        );
    } else {
        println!(
            "DONE: {}",
            "Compilation failed, please unroll the unsafe changes".red()
        );
    }
}
